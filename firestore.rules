rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isShortString(value, maxLen) {
      return value is string && value.size() <= maxLen;
    }

    function isScore(value) {
      return value is number && value >= 0 && value <= 100;
    }

    function isNonNegativeInt(value) {
      return value is number && value >= 0 && value == value.floor();
    }

    function hasValidVerdict(value) {
      return value == null ||
        value in ['Likely AI-generated', 'Possibly AI-assisted', 'Likely human-authored'];
    }

    function isValidIndicators(value) {
      return value == null || (value is list && value.size() <= 6);
    }

    function isValidAiDetection(value) {
      return value == null || (
        value is map &&
        (!('verdict' in value) || hasValidVerdict(value.verdict)) &&
        (!('likelihoodScore' in value) || isScore(value.likelihoodScore)) &&
        (!('confidence' in value) || isScore(value.confidence)) &&
        (!('rationale' in value) || isShortString(value.rationale, 2000)) &&
        (!('indicators' in value) || isValidIndicators(value.indicators))
      );
    }

    function isValidCommunityDoc(data) {
      return data.keys().hasOnly([
        'headline',
        'summary',
        'credibilityScore',
        'aiVerdict',
        'aiDetection',
        'timestamp',
        'supportCount',
        'disputeCount',
        'userVotes'
      ]) &&
      ('headline' in data && isShortString(data.headline, 512)) &&
      ('summary' in data && isShortString(data.summary, 5000)) &&
      ('credibilityScore' in data && isScore(data.credibilityScore)) &&
      (!('aiVerdict' in data) || hasValidVerdict(data.aiVerdict)) &&
      (!('aiDetection' in data) || isValidAiDetection(data.aiDetection)) &&
      (!('timestamp' in data) || data.timestamp is timestamp) &&
      (!('supportCount' in data) || isNonNegativeInt(data.supportCount)) &&
      (!('disputeCount' in data) || isNonNegativeInt(data.disputeCount)) &&
      (!('userVotes' in data) || data.userVotes is map);
    }

    match /communityFeed/{entryId} {
      allow read: if isSignedIn();

      // UPDATED: For create, ensure supportCount and disputeCount start at 0
      allow create: if isSignedIn() &&
                    isValidCommunityDoc(request.resource.data) &&
                    request.resource.data.supportCount == 0 &&
                    request.resource.data.disputeCount == 0;

      // UPDATED: Now, the client cannot directly update supportCount or disputeCount.
      // Allow updates to vote-related fields with proper validation
      allow update: if isSignedIn() && (
        isValidCommunityDoc(request.resource.data) ||
        (
          request.resource.keys().hasOnly(['supportCount', 'disputeCount', 'userVotes']) &&
          request.resource.data.supportCount is number &&
          request.resource.data.disputeCount is number &&
          request.resource.data.userVotes is map &&
          request.resource.data.userVotes.diff(resource.data.userVotes).addedKeys().hasOnly([request.auth.uid]) &&
          request.resource.data.userVotes.diff(resource.data.userVotes).changedKeys().hasOnly([request.auth.uid]) &&
          request.resource.data.userVotes.diff(resource.data.userVotes).removedKeys().hasOnly([request.auth.uid])
        )
      );


      allow delete: if false; // No deletion of main community feed entries

      // NEW: Rules for the 'votes' subcollection
      match /votes/{userId} {
        // Users can read all votes for a community entry (e.g., to see who voted what)
        allow read: if isSignedIn();

        // A user can create their own vote document.
        // userId in the path must match the authenticated user's UID.
        allow create: if isSignedIn() &&
                      request.auth.uid == userId && // User ID in path must match
                      request.resource.data.keys().hasAll(['vote', 'timestamp']) &&
                      request.resource.data.vote in ['support', 'dispute'] &&
                      request.resource.data.timestamp is timestamp;

        // A user can update their own vote document (e.g., change vote type).
        // userId in the path must match the authenticated user's UID.
        allow update: if isSignedIn() &&
                      request.auth.uid == userId && // User ID in path must match
                      request.resource.data.keys().hasAll(['vote', 'timestamp']) &&
                      request.resource.data.vote in ['support', 'dispute'] &&
                      request.resource.data.timestamp is timestamp;

        // A user can delete their own vote document.
        // userId in the path must match the authenticated user's UID.
        allow delete: if isSignedIn() && request.auth.uid == userId;
      }
    }

    match /users/{userId} {
      allow read: if isSignedIn();
      allow write: if isSignedIn() && request.auth.uid == userId;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
